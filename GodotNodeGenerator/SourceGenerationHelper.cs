using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace GodotNodeGenerator
{
    // Node tree helper for building the wrapper classes
    internal class NodeTreeItem
    {
        public NodeInfo Info { get; set; } = null!;
        public string Name { get; set; } = string.Empty;
        public string Path { get; set; } = string.Empty;
        public string GodotType { get; set; } = string.Empty;
        public NodeTreeItem? Parent { get; set; }
        public Dictionary<string, NodeTreeItem> Children { get; } = new Dictionary<string, NodeTreeItem>();
    }

    public static class SourceGenerationHelper
    {
        // The source code for the attribute, which will be embedded in the assembly
        public static readonly string AttributeText = @"
using System;

namespace GodotNodeGenerator
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class NodeGeneratorAttribute : Attribute
    {
        public string? ScenePath { get; }

        public NodeGeneratorAttribute(string? scenePath = null)
        {
            ScenePath = scenePath;
        }
    }
}";

        // Generate node accessor code
        public static string GenerateNodeAccessors(
            string namespaceName,
            string className,
            List<NodeInfo> nodeInfos)
        {
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
using Godot;
using System;
using System.Diagnostics.CodeAnalysis;
using System.Collections.Generic;

namespace {namespaceName}
{{
    // Generated node accessors for {className}
    public partial class {className}
    {{");

            // Generate standard accessors for all nodes first
            foreach (var nodeInfo in nodeInfos)
            {
                var safeName = MakeSafeIdentifier(nodeInfo.Name);
                var godotType = MapGodotTypeToCS(nodeInfo.Type);

                // Check if there's a script associated with this node
                var isCustomType = IsCustomType(nodeInfo);
                var scriptComment = isCustomType
                    ? $" (script: \"{nodeInfo.Script}\")"
                    : "";

                // Generate property with better error handling
                sb.AppendLine($@"
        private {godotType}? _{safeName};
        
        /// <summary>
        /// Gets the {nodeInfo.Name} node (path: ""{nodeInfo.Path}""){scriptComment}
        /// </summary>
        /// <exception cref=""InvalidCastException"">Thrown when the node at the specified path is not of type {godotType}.</exception>
        /// <exception cref=""NullReferenceException"">Thrown when the node is not found in the scene tree.</exception>
        [return: NotNull]
        public {godotType} {safeName} 
        {{
            get
            {{
                if (_{safeName} == null)
                {{
                    var node = GetNodeOrNull(""{nodeInfo.Path}"");
                    if (node == null)
                    {{
                        throw new NullReferenceException($""Node not found: {nodeInfo.Path}"");
                    }}
                    
                    _{safeName} = node as {godotType};
                    if (_{safeName} == null)
                    {{
                        throw new InvalidCastException($""Node at path {{node.GetPath()}} is of type {{node.GetType()}}, not {godotType}"");
                    }}
                }}
                
                return _{safeName};
            }}
        }}");

                // Add a TryGet method for safe access
                sb.AppendLine($@"
        /// <summary>
        /// Tries to get the {nodeInfo.Name} node (path: ""{nodeInfo.Path}"") 
        /// without throwing exceptions if the node doesn't exist or is of wrong type.
        /// </summary>
        /// <returns>True if the node was found and is of the correct type, otherwise false.</returns>
        public bool TryGet{safeName}([NotNullWhen(true)] out {godotType}? node)
        {{
            node = null;
            if (_{safeName} != null)
            {{
                node = _{safeName};
                return true;
            }}
            
            var tempNode = GetNodeOrNull(""{nodeInfo.Path}"");
            if (tempNode is {godotType} typedNode)
            {{
                _{safeName} = typedNode;
                node = typedNode;
                return true;
            }}
            
            return false;
        }}");
            }
            
            // Now generate the node tree wrapper classes
            sb.AppendLine(@"
        #region Node Tree Accessors");

            // Build a tree of nodes
            var nodeTree = BuildNodeTree(nodeInfos);
            
            // Generate wrapper classes for nodes with children
            foreach (var node in nodeTree.Values)
            {
                if (node.Children.Count > 0)
                {
                    GenerateNodeWrapperClass(sb, node, 2, className);
                }
            }
            
            // Generate properties for top-level nodes with children
            foreach (var node in nodeTree.Values)
            {
                if (node.Parent == null && node.Children.Count > 0)
                {
                    GenerateNodeProperty(sb, node, 2);
                }
            }
            
            sb.AppendLine(@"
        #endregion");

            // Close the class and namespace
            sb.AppendLine(@"    }
}");

            return sb.ToString();
        }

        // Convert a node name to a valid C# identifier
        private static string MakeSafeIdentifier(string name)
        {
            // Simple implementation - replace invalid characters with underscore
            var result = new StringBuilder();
            
            // Ensure it starts with a letter or underscore
            if (name.Length > 0 && !char.IsLetter(name[0]) && name[0] != '_')
            {
                result.Append('_');
            }
            
            foreach (var c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    result.Append(c);
                }
                else
                {
                    result.Append('_');
                }
            }
            
            return result.ToString();
        }

        // Map Godot node types to C# types
        private static string MapGodotTypeToCS(string godotType)
        {
            return godotType switch
            {
                // Basic Node types
                "Node" => "Node",
                "Node2D" => "Node2D",
                "Node3D" => "Node3D",
                
                // UI Controls
                "Control" => "Control",
                "Label" => "Label",
                "Button" => "Button",
                "LineEdit" => "LineEdit",
                "TextEdit" => "TextEdit",
                "RichTextLabel" => "RichTextLabel",
                "Panel" => "Panel",
                "PanelContainer" => "PanelContainer",
                "TabContainer" => "TabContainer",
                "ProgressBar" => "ProgressBar",
                "ScrollContainer" => "ScrollContainer",
                "ItemList" => "ItemList",
                "Tree" => "Tree",
                "OptionButton" => "OptionButton",
                "CheckBox" => "CheckBox",
                "CheckButton" => "CheckButton",
                "ColorRect" => "ColorRect",
                "TextureRect" => "TextureRect",
                "Slider" => "Slider",
                "HSlider" => "HSlider",
                "VSlider" => "VSlider",
                "SpinBox" => "SpinBox",
                
                // 2D Nodes
                "Sprite2D" => "Sprite2D",
                "AnimatedSprite2D" => "AnimatedSprite2D",
                "CPUParticles2D" => "CpuParticles2D",
                "GPUParticles2D" => "GpuParticles2D",
                "TileMap" => "TileMap",
                "Line2D" => "Line2D",
                "Polygon2D" => "Polygon2D",
                "Path2D" => "Path2D",
                "CollisionShape2D" => "CollisionShape2D",
                "CollisionPolygon2D" => "CollisionPolygon2D",
                "Area2D" => "Area2D",
                "StaticBody2D" => "StaticBody2D",
                "RigidBody2D" => "RigidBody2D",
                "CharacterBody2D" => "CharacterBody2D",
                "CanvasLayer" => "CanvasLayer",
                "CanvasGroup" => "CanvasGroup",
                "AnimationPlayer" => "AnimationPlayer",
                "AnimationTree" => "AnimationTree",
                
                // 3D Nodes
                "MeshInstance3D" => "MeshInstance3D",
                "Sprite3D" => "Sprite3D",
                "DirectionalLight3D" => "DirectionalLight3D",
                "OmniLight3D" => "OmniLight3D",
                "SpotLight3D" => "SpotLight3D",
                "CollisionShape3D" => "CollisionShape3D",
                "CollisionPolygon3D" => "CollisionPolygon3D",
                "Area3D" => "Area3D",
                "StaticBody3D" => "StaticBody3D",
                "RigidBody3D" => "RigidBody3D",
                "CharacterBody3D" => "CharacterBody3D",
                
                // Camera and Audio
                "Camera2D" => "Camera2D",
                "Camera3D" => "Camera3D",
                "AudioStreamPlayer" => "AudioStreamPlayer",
                "AudioStreamPlayer2D" => "AudioStreamPlayer2D",
                "AudioStreamPlayer3D" => "AudioStreamPlayer3D",
                
                // Default to Node if unknown
                _ => "Node" 
            };
        }
        
        // Check if a type is a custom script
        private static bool IsCustomType(NodeInfo nodeInfo)
        {
            return !string.IsNullOrEmpty(nodeInfo.Script);
        }

        // Build a tree structure from the list of nodes
        private static Dictionary<string, NodeTreeItem> BuildNodeTree(List<NodeInfo> nodeInfos)
        {
            var nodeTree = new Dictionary<string, NodeTreeItem>();

            // First, create all nodes in the tree
            foreach (var nodeInfo in nodeInfos)
            {
                var treeItem = new NodeTreeItem
                {
                    Info = nodeInfo,
                    Name = nodeInfo.Name,
                    Path = nodeInfo.Path,
                    GodotType = MapGodotTypeToCS(nodeInfo.Type)
                };
                
                nodeTree[nodeInfo.Path] = treeItem;
            }

            // Then, build the parent-child relationships
            foreach (var node in nodeTree.Values.ToList())
            {
                // Skip root nodes
                if (!node.Path.Contains("/"))
                    continue;

                // Find the parent path
                var lastSlash = node.Path.LastIndexOf('/');
                if (lastSlash <= 0) continue;
                
                var parentPath = node.Path.Substring(0, lastSlash);
                
                // Add as child to parent
                if (nodeTree.TryGetValue(parentPath, out var parentNode))
                {
                    node.Parent = parentNode;
                    parentNode.Children[node.Name] = node;
                }
            }

            return nodeTree;
        }

        // Generate a wrapper class for a node and its children
        private static void GenerateNodeWrapperClass(StringBuilder sb, NodeTreeItem node, int indentLevel, string rootClassName)
        {
            string indent = new string(' ', indentLevel * 4);
            var godotType = node.GodotType;
            var nodeName = node.Name;
            var safeName = MakeSafeIdentifier(nodeName);

            // Skip if no children
            if (node.Children.Count == 0)
                return;
                
            // Generate the wrapper class
            sb.AppendLine($@"
{indent}/// <summary>
{indent}/// Wrapper class for {nodeName} node providing access to its child nodes.
{indent}/// </summary>
{indent}public class {safeName}Wrapper
{indent}{{
{indent}    private readonly {rootClassName} _owner;
{indent}    private readonly {godotType} _node;
{indent}    
{indent}    internal {safeName}Wrapper({rootClassName} owner, {godotType} node)
{indent}    {{
{indent}        _owner = owner;
{indent}        _node = node;
{indent}    }}
{indent}    
{indent}    /// <summary>
{indent}    /// Gets the underlying Godot {godotType} node.
{indent}    /// </summary>
{indent}    public {godotType} Node => _node;");

            // Generate properties for child nodes
            foreach (var child in node.Children.Values)
            {
                var childSafeName = MakeSafeIdentifier(child.Name);
                var childGodotType = child.GodotType;
                
                // If this child has children, generate a wrapper property
                if (child.Children.Count > 0)
                {
                    // Property returning a wrapper
                    sb.AppendLine($@"
{indent}    private {childSafeName}Wrapper? _{childSafeName};
{indent}    
{indent}    /// <summary>
{indent}    /// Gets the {child.Name} node wrapper.
{indent}    /// </summary>
{indent}    public {childSafeName}Wrapper {childSafeName}
{indent}    {{
{indent}        get
{indent}        {{
{indent}            if (_{childSafeName} == null)
{indent}            {{
{indent}                _{childSafeName} = new {childSafeName}Wrapper(_owner, _owner.{childSafeName});
{indent}            }}
{indent}            return _{childSafeName};
{indent}        }}
{indent}    }}");
                    
                    // Generate wrapper for this child too
                    GenerateNodeWrapperClass(sb, child, indentLevel + 1, rootClassName);
                }
                else
                {
                    // Direct property for leaf node
                    sb.AppendLine($@"
{indent}    /// <summary>
{indent}    /// Gets the {child.Name} node.
{indent}    /// </summary>
{indent}    public {childGodotType} {childSafeName} => _owner.{childSafeName};");
                }
            }
            
            // Close the class
            sb.AppendLine($"{indent}}}");
        }

        // Generate a property for a node in the parent class
        private static void GenerateNodeProperty(StringBuilder sb, NodeTreeItem node, int indentLevel)
        {
            string indent = new string(' ', indentLevel * 4);
            var safeName = MakeSafeIdentifier(node.Name);
            var godotType = node.GodotType;
            
            // Skip if node has no children
            if (node.Children.Count == 0)
                return;

            // Generate wrapper property for the root class
            sb.AppendLine($@"
{indent}private {safeName}Wrapper? _{safeName}Wrapper;

{indent}/// <summary>
{indent}/// Gets a wrapper for the {node.Name} node that provides access to its child nodes.
{indent}/// </summary>
{indent}public {safeName}Wrapper {safeName}
{indent}{{
{indent}    get
{indent}    {{
{indent}        if (_{safeName}Wrapper == null)
{indent}        {{
{indent}            _{safeName}Wrapper = new {safeName}Wrapper(this, {safeName});
{indent}        }}
{indent}        return _{safeName}Wrapper;
{indent}    }}
{indent}}}");
        }
    }

    // Represents a node in a Godot scene
    public class NodeInfo
    {
        public string Name { get; set; } = "";
        public string Path { get; set; } = "";
        public string Type { get; set; } = "Node";
        public string? Script { get; set; } = null;
        public bool IsExportedProperty { get; set; } = false;
        public Dictionary<string, string> Properties { get; set; } = new Dictionary<string, string>();    }
}

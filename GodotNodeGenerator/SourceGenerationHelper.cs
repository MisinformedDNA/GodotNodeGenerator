using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace GodotNodeGenerator
{
    // Node tree helper for building the wrapper classes
    internal class NodeTreeItem
    {
        public NodeInfo Info { get; set; } = null!;
        public string Name { get; set; } = string.Empty;
        public string Path { get; set; } = string.Empty;
        public string GodotType { get; set; } = string.Empty;
        public NodeTreeItem? Parent { get; set; }
        public Dictionary<string, NodeTreeItem> Children { get; } = [];
    }

    public static class SourceGenerationHelper
    {
        // The source code for the attribute, which will be embedded in the assembly
        public static readonly string AttributeText = @"
using System;

namespace GodotNodeGenerator
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class NodeGeneratorAttribute : Attribute
    {
        public string? ScenePath { get; }

        public NodeGeneratorAttribute(string? scenePath = null)
        {
            ScenePath = scenePath;
        }
    }
}";

        // Generate node accessor code
        public static string GenerateNodeAccessors(
            string namespaceName,
            string className,
            List<NodeInfo> nodeInfos)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"// <auto-generated/>");
            sb.AppendLine("using Godot;");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();

            // Handle file-scoped namespace, block namespace, or no namespace
            bool hasNamespace = !string.IsNullOrWhiteSpace(namespaceName) && namespaceName != "<global namespace>";
            bool isFileScoped = hasNamespace && namespaceName.TrimEnd().EndsWith(";");

            if (hasNamespace)
            {
                if (isFileScoped)
                {
                    // Emit file-scoped namespace
                    sb.AppendLine($"namespace {namespaceName.TrimEnd(';').Trim()};");
                }
                else
                {
                    // Emit block namespace
                    sb.AppendLine($"namespace {namespaceName}");
                    sb.AppendLine("{");
                }
            }

            // Indent if using block namespace
            string indent = (hasNamespace && !isFileScoped) ? "    " : string.Empty;

            sb.AppendLine($"{indent}// Generated node accessors for {className}");
            sb.AppendLine($"{indent}public partial class {className}");
            sb.AppendLine($"{indent}{{");

            bool firstField = true;
            int nodeIndex = 0;
            foreach (var nodeInfo in nodeInfos)
            {
                var safeName = MakeSafeIdentifier(nodeInfo.Name, className);
                var godotType = MapGodotTypeToCS(nodeInfo.Type);
                var isCustomType = IsCustomType(nodeInfo);
                var scriptComment = isCustomType ? $" (script: \"{nodeInfo.Script}\")" : "";

                if (!firstField) sb.AppendLine(); // blank line before each field except first
                firstField = false;
                sb.AppendLine($"{indent}    private {godotType}? _{safeName};");
                sb.AppendLine();
                sb.AppendLine($"{indent}    /// <summary>");
                sb.AppendLine($"{indent}    /// Gets the {nodeInfo.Name} node (path: \"{nodeInfo.Path}\"){scriptComment}");
                sb.AppendLine($"{indent}    /// </summary>");
                sb.AppendLine($"{indent}    /// <exception cref=\"InvalidCastException\">Thrown when the node at the specified path is not of type {godotType}.</exception>");
                sb.AppendLine($"{indent}    /// <exception cref=\"NullReferenceException\">Thrown when the node is not found in the scene tree.</exception>");
                sb.AppendLine($"{indent}    [return: NotNull]");
                sb.AppendLine($"{indent}    public {godotType} {safeName}");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        get");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            if (_{safeName} == null)");
                sb.AppendLine($"{indent}            {{");
                sb.AppendLine($"{indent}                var node = GetNodeOrNull(\"{nodeInfo.Path}\");");
                sb.AppendLine($"{indent}                if (node == null)");
                sb.AppendLine($"{indent}                {{");
                sb.AppendLine($"{indent}                    throw new NullReferenceException($\"Node not found: {nodeInfo.Path}\");");
                sb.AppendLine($"{indent}                }}");
                sb.AppendLine();
                sb.AppendLine($"{indent}                _{safeName} = node as {godotType};");
                sb.AppendLine($"{indent}                if (_{safeName} == null)");
                sb.AppendLine($"{indent}                {{");
                sb.AppendLine($"{indent}                    throw new InvalidCastException($\"Node at path {{node.GetPath()}} is of type {{node.GetType()}}, not {godotType}\");");
                sb.AppendLine($"{indent}                }}");
                sb.AppendLine($"{indent}            }}");
                sb.AppendLine();
                sb.AppendLine($"{indent}            return _{safeName};");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine();

                // TryGet method
                sb.AppendLine($"{indent}    /// <summary>");
                sb.AppendLine($"{indent}    /// Tries to get the {nodeInfo.Name} node (path: \"{nodeInfo.Path}\") ");
                sb.AppendLine($"{indent}    /// without throwing exceptions if the node doesn't exist or is of wrong type.");
                sb.AppendLine($"{indent}    /// </summary>");
                sb.AppendLine($"{indent}    /// <returns>True if the node was found and is of the correct type, otherwise false.</returns>");
                sb.AppendLine($"{indent}    public bool TryGet{safeName}([NotNullWhen(true)] out {godotType}? node)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        node = null;");
                sb.AppendLine($"{indent}        if (_{safeName} != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            node = _{safeName};");
                sb.AppendLine($"{indent}            return true;");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine();
                sb.AppendLine($"{indent}        var tempNode = GetNodeOrNull(\"{nodeInfo.Path}\");");
                sb.AppendLine($"{indent}        if (tempNode is {godotType} typedNode)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            _{safeName} = typedNode;");
                sb.AppendLine($"{indent}            node = typedNode;");
                sb.AppendLine($"{indent}            return true;");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine();
                sb.AppendLine($"{indent}        return false;");
                sb.AppendLine($"{indent}    }}");
                nodeIndex++;
            }
            sb.AppendLine();
            sb.AppendLine($"{indent}    #region Node Tree Accessors");
            var nodeTree = BuildNodeTree(nodeInfos, className);
            foreach (var node in nodeTree.Values)
            {
                if (node.Children.Count > 0)
                {
                    GenerateNodeWrapperClass(sb, node, (hasNamespace && !isFileScoped) ? 2 : 1, className);
                }
            }
            foreach (var node in nodeTree.Values)
            {
                if (node.Parent == null && node.Children.Count > 0)
                {
                    GenerateNodeProperty(sb, node, (hasNamespace && !isFileScoped) ? 2 : 1, className);
                }
            }            
            sb.AppendLine();
            sb.AppendLine($"{indent}    #endregion");
            sb.AppendLine($"{indent}}}"); // close class

            if (hasNamespace && !isFileScoped)
            {
                sb.AppendLine("}"); // close namespace block
            }

            return sb.ToString();
        }

        // Convert a node name to a valid C# identifier
        private static string MakeSafeIdentifier(string name, string className = "")
        {
            // Simple implementation - replace invalid characters with underscore
            var result = new StringBuilder();
            
            // Ensure it starts with a letter or underscore
            if (name.Length > 0 && !char.IsLetter(name[0]) && name[0] != '_')
            {
                result.Append('_');
            }
            
            foreach (var c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    result.Append(c);
                }
                else
                {
                    result.Append('_');
                }
            }
            
            var identifier = result.ToString();
            
            // If the property name would be the same as the class name, append "Node" to avoid C# error
            if (!string.IsNullOrEmpty(className) && identifier == className)
            {
                identifier += "Node";
            }
            
            return identifier;
        }

        // Map Godot node types to C# types
        private static string MapGodotTypeToCS(string godotType)
        {
            return godotType switch
            {
                // Basic Node types
                "Node" => "Node",
                "Node2D" => "Node2D",
                "Node3D" => "Node3D",
                
                // UI Controls
                "Control" => "Control",
                "Label" => "Label",
                "Button" => "Button",
                "LineEdit" => "LineEdit",
                "TextEdit" => "TextEdit",
                "RichTextLabel" => "RichTextLabel",
                "Panel" => "Panel",
                "PanelContainer" => "PanelContainer",
                "TabContainer" => "TabContainer",
                "ProgressBar" => "ProgressBar",
                "ScrollContainer" => "ScrollContainer",
                "ItemList" => "ItemList",
                "Tree" => "Tree",
                "OptionButton" => "OptionButton",
                "CheckBox" => "CheckBox",
                "CheckButton" => "CheckButton",
                "ColorRect" => "ColorRect",
                "TextureRect" => "TextureRect",
                "Slider" => "Slider",
                "HSlider" => "HSlider",
                "VSlider" => "VSlider",
                "SpinBox" => "SpinBox",
                
                // 2D Nodes
                "Sprite2D" => "Sprite2D",
                "AnimatedSprite2D" => "AnimatedSprite2D",
                "CPUParticles2D" => "CpuParticles2D",
                "GPUParticles2D" => "GpuParticles2D",
                "TileMap" => "TileMap",
                "Line2D" => "Line2D",
                "Polygon2D" => "Polygon2D",
                "Path2D" => "Path2D",
                "CollisionShape2D" => "CollisionShape2D",
                "CollisionPolygon2D" => "CollisionPolygon2D",
                "Area2D" => "Area2D",
                "StaticBody2D" => "StaticBody2D",
                "RigidBody2D" => "RigidBody2D",
                "CharacterBody2D" => "CharacterBody2D",
                "CanvasLayer" => "CanvasLayer",
                "CanvasGroup" => "CanvasGroup",
                "AnimationPlayer" => "AnimationPlayer",
                "AnimationTree" => "AnimationTree",
                
                // 3D Nodes
                "MeshInstance3D" => "MeshInstance3D",
                "Sprite3D" => "Sprite3D",
                "DirectionalLight3D" => "DirectionalLight3D",
                "OmniLight3D" => "OmniLight3D",
                "SpotLight3D" => "SpotLight3D",
                "CollisionShape3D" => "CollisionShape3D",
                "CollisionPolygon3D" => "CollisionPolygon3D",
                "Area3D" => "Area3D",
                "StaticBody3D" => "StaticBody3D",
                "RigidBody3D" => "RigidBody3D",
                "CharacterBody3D" => "CharacterBody3D",
                
                // Camera and Audio
                "Camera2D" => "Camera2D",
                "Camera3D" => "Camera3D",
                "AudioStreamPlayer" => "AudioStreamPlayer",
                "AudioStreamPlayer2D" => "AudioStreamPlayer2D",
                "AudioStreamPlayer3D" => "AudioStreamPlayer3D",
                
                // Default to Node if unknown
                _ => "Node" 
            };
        }
        
        // Check if a type is a custom script
        private static bool IsCustomType(NodeInfo nodeInfo)
        {
            return !string.IsNullOrEmpty(nodeInfo.Script);
        }

        // Build a tree structure from the list of nodes
        private static Dictionary<string, NodeTreeItem> BuildNodeTree(List<NodeInfo> nodeInfos, string className)
        {
            var nodeTree = new Dictionary<string, NodeTreeItem>();

            // First, create all nodes in the tree
            foreach (var nodeInfo in nodeInfos)
            {
                var treeItem = new NodeTreeItem
                {
                    Info = nodeInfo,
                    Name = MakeSafeIdentifier(nodeInfo.Name, className),
                    Path = nodeInfo.Path,
                    GodotType = MapGodotTypeToCS(nodeInfo.Type)
                };
                
                nodeTree[nodeInfo.Path] = treeItem;
            }

            // Then, build the parent-child relationships
            foreach (var node in nodeTree.Values.ToList())
            {
                // Skip root nodes
                if (!node.Path.Contains("/"))
                    continue;

                // Find the parent path
                var lastSlash = node.Path.LastIndexOf('/');
                if (lastSlash <= 0) continue;
                
                var parentPath = node.Path[..lastSlash];
                
                // Add as child to parent
                if (nodeTree.TryGetValue(parentPath, out var parentNode))
                {
                    node.Parent = parentNode;
                    parentNode.Children[node.Name] = node;
                }
            }

            return nodeTree;
        }

        // Generate a wrapper class for a node and its children
        private static void GenerateNodeWrapperClass(StringBuilder sb, NodeTreeItem node, int indentLevel, string rootClassName)
        {
            string indent = new(' ', indentLevel * 4);
            var godotType = node.GodotType;
            var nodeName = node.Name;
            var safeName = MakeSafeIdentifier(nodeName, rootClassName);

            // Skip if no children
            if (node.Children.Count == 0)
                return;
                
            // Generate the wrapper class
            sb.AppendLine($@"
{indent}/// <summary>
{indent}/// Wrapper class for {nodeName} node providing access to its child nodes.
{indent}/// </summary>
{indent}public class {safeName}Wrapper
{indent}{{
{indent}    private readonly {rootClassName} _owner;
{indent}    private readonly {godotType} _node;

{indent}    internal {safeName}Wrapper({rootClassName} owner, {godotType} node)
{indent}    {{
{indent}        _owner = owner;
{indent}        _node = node;
{indent}    }}

{indent}    /// <summary>
{indent}    /// Gets the underlying Godot {godotType} node.
{indent}    /// </summary>
{indent}    public {godotType} Node => _node;");

            // Generate properties for child nodes
            foreach (var child in node.Children.Values)
            {
                var childSafeName = MakeSafeIdentifier(child.Name, rootClassName);
                var childGodotType = child.GodotType;
                
                // If this child has children, generate a wrapper property
                if (child.Children.Count > 0)
                {
                    // Property returning a wrapper
                    sb.AppendLine($@"
{indent}    private {childSafeName}Wrapper? _{childSafeName};
{indent}    
{indent}    /// <summary>
{indent}    /// Gets the {child.Name} node wrapper.
{indent}    /// </summary>
{indent}    public {childSafeName}Wrapper {childSafeName}
{indent}    {{
{indent}        get
{indent}        {{
{indent}            if (_{childSafeName} == null)
{indent}            {{
{indent}                _{childSafeName} = new {childSafeName}Wrapper(_owner, _owner.{childSafeName});
{indent}            }}
{indent}            return _{childSafeName};
{indent}        }}
{indent}    }}");
                    
                    // Generate wrapper for this child too
                    GenerateNodeWrapperClass(sb, child, indentLevel + 1, rootClassName);
                }
                else
                {
                    // Direct property for leaf node
                    sb.AppendLine($@"
{indent}    /// <summary>
{indent}    /// Gets the {child.Name} node.
{indent}    /// </summary>
{indent}    public {childGodotType} {childSafeName} => _owner.{childSafeName};");
                }
            }
            
            // Close the class
            sb.AppendLine($"{indent}}}");
        }

        // Generate a property for a node in the parent class
        private static void GenerateNodeProperty(StringBuilder sb, NodeTreeItem node, int indentLevel, string className)
        {
            string indent = new(' ', indentLevel * 4);
            var safeName = MakeSafeIdentifier(node.Name, className);
            
            // Skip if node has no children
            if (node.Children.Count == 0)
                return;

            // Generate wrapper property for the root class
            sb.AppendLine($@"
{indent}private {safeName}Wrapper? _{safeName}Wrapper;

{indent}/// <summary>
{indent}/// Gets a wrapper for the {node.Name} node that provides access to its child nodes.
{indent}/// </summary>
{indent}public {safeName}Wrapper {safeName}Nodes
{indent}{{
{indent}    get
{indent}    {{
{indent}        if (_{safeName}Wrapper == null)
{indent}        {{
{indent}            _{safeName}Wrapper = new {safeName}Wrapper(this, {safeName});
{indent}        }}
{indent}        return _{safeName}Wrapper;
{indent}    }}
{indent}}}");
        }
    }

    // Represents a node in a Godot scene
    public class NodeInfo
    {
        public string Name { get; set; } = "";
        public string Path { get; set; } = "";
        public string Type { get; set; } = "Node";
        public string? Script { get; set; } = null;
        public bool IsExportedProperty { get; set; } = false;
        public Dictionary<string, string> Properties { get; set; } = [];
    }
}

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Text;

namespace GodotNodeGenerator
{
    public static class SourceGenerationHelper
    {
        // The source code for the attribute, which will be embedded in the assembly
        public static readonly string AttributeText = @"
using System;

namespace GodotNodeGenerator
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class NodeGeneratorAttribute : Attribute
    {
        public string? ScenePath { get; }

        public NodeGeneratorAttribute(string? scenePath = null)
        {
            ScenePath = scenePath;
        }
    }
}";

        // Generate node accessor code
        public static string GenerateNodeAccessors(
            string namespaceName,
            string className,
            List<NodeInfo> nodeInfos)
        {
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
using Godot;
using System;
using System.Diagnostics.CodeAnalysis;

namespace {namespaceName}
{{
    // Generated node accessors for {className}
    public partial class {className}
    {{");

            // Generate a property for each node
            foreach (var nodeInfo in nodeInfos)
            {
                var safeName = MakeSafeIdentifier(nodeInfo.Name);
                var godotType = MapGodotTypeToCS(nodeInfo.Type);

                // Check if there's a script associated with this node
                var isCustomType = IsCustomType(nodeInfo);
                var scriptComment = isCustomType
                    ? $" (script: \"{nodeInfo.Script}\")"
                    : "";

                // Generate property with better error handling
                sb.AppendLine($@"
        private {godotType}? _{safeName};
        
        /// <summary>
        /// Gets the {nodeInfo.Name} node (path: ""{nodeInfo.Path}""){scriptComment}
        /// </summary>
        /// <exception cref=""InvalidCastException"">Thrown when the node at the specified path is not of type {godotType}.</exception>
        /// <exception cref=""NullReferenceException"">Thrown when the node is not found in the scene tree.</exception>
        [return: NotNull]
        public {godotType} {safeName} 
        {{
            get
            {{
                if (_{safeName} == null)
                {{
                    var node = GetNodeOrNull(""{nodeInfo.Path}"");
                    if (node == null)
                    {{
                        throw new NullReferenceException($""Node not found: {nodeInfo.Path}"");
                    }}
                    
                    _{safeName} = node as {godotType};
                    if (_{safeName} == null)
                    {{
                        throw new InvalidCastException($""Node at path {{node.GetPath()}} is of type {{node.GetType()}}, not {godotType}"");
                    }}
                }}
                
                return _{safeName};
            }}
        }}");

                // Add a TryGet method for safe access
                sb.AppendLine($@"
        /// <summary>
        /// Tries to get the {nodeInfo.Name} node (path: ""{nodeInfo.Path}"") 
        /// without throwing exceptions if the node doesn't exist or is of wrong type.
        /// </summary>
        /// <returns>True if the node was found and is of the correct type, otherwise false.</returns>
        public bool TryGet{safeName}([NotNullWhen(true)] out {godotType}? node)
        {{
            node = null;
            if (_{safeName} != null)
            {{
                node = _{safeName};
                return true;
            }}
            
            var tempNode = GetNodeOrNull(""{nodeInfo.Path}"");
            if (tempNode is {godotType} typedNode)
            {{
                _{safeName} = typedNode;
                node = typedNode;
                return true;
            }}
            
            return false;
        }}");
            }

            sb.AppendLine(@"    }
}");

            return sb.ToString();
        }

        // Convert a node name to a valid C# identifier
        private static string MakeSafeIdentifier(string name)
        {
            // Simple implementation - replace invalid characters with underscore
            var result = new StringBuilder();
            
            // Ensure it starts with a letter or underscore
            if (!char.IsLetter(name[0]) && name[0] != '_')
            {
                result.Append('_');
            }
            
            foreach (var c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    result.Append(c);
                }
                else
                {
                    result.Append('_');
                }
            }
            
            return result.ToString();
        }

        // Map Godot node types to C# types
        private static string MapGodotTypeToCS(string godotType)
        {
            return godotType switch
            {
                // Basic Node types
                "Node" => "Node",
                "Node2D" => "Node2D",
                "Node3D" => "Node3D",
                
                // UI Controls
                "Control" => "Control",
                "Label" => "Label",
                "Button" => "Button",
                "LineEdit" => "LineEdit",
                "TextEdit" => "TextEdit",
                "RichTextLabel" => "RichTextLabel",
                "Panel" => "Panel",
                "TabContainer" => "TabContainer",
                "ProgressBar" => "ProgressBar",
                "ScrollContainer" => "ScrollContainer",
                "ItemList" => "ItemList",
                "Tree" => "Tree",
                "OptionButton" => "OptionButton",
                "CheckBox" => "CheckBox",
                "CheckButton" => "CheckButton",
                "ColorRect" => "ColorRect",
                "TextureRect" => "TextureRect",
                "Slider" => "Slider",
                "HSlider" => "HSlider",
                "VSlider" => "VSlider",
                "SpinBox" => "SpinBox",
                
                // 2D Nodes
                "Sprite2D" => "Sprite2D",
                "AnimatedSprite2D" => "AnimatedSprite2D",
                "CPUParticles2D" => "CpuParticles2D",
                "GPUParticles2D" => "GpuParticles2D",
                "TileMap" => "TileMap",
                "Line2D" => "Line2D",
                "Polygon2D" => "Polygon2D",
                "Path2D" => "Path2D",
                "CollisionShape2D" => "CollisionShape2D",
                "CollisionPolygon2D" => "CollisionPolygon2D",
                "Area2D" => "Area2D",
                "StaticBody2D" => "StaticBody2D",
                "RigidBody2D" => "RigidBody2D",
                "CharacterBody2D" => "CharacterBody2D",
                "CanvasLayer" => "CanvasLayer",
                "CanvasGroup" => "CanvasGroup",
                "AnimationPlayer" => "AnimationPlayer",
                "AnimationTree" => "AnimationTree",
                
                // 3D Nodes
                "MeshInstance3D" => "MeshInstance3D",
                "Sprite3D" => "Sprite3D",
                "DirectionalLight3D" => "DirectionalLight3D",
                "OmniLight3D" => "OmniLight3D",
                "SpotLight3D" => "SpotLight3D",
                "CollisionShape3D" => "CollisionShape3D",
                "CollisionPolygon3D" => "CollisionPolygon3D",
                "Area3D" => "Area3D",
                "StaticBody3D" => "StaticBody3D",
                "RigidBody3D" => "RigidBody3D",
                "CharacterBody3D" => "CharacterBody3D",
                
                // Camera and Audio
                "Camera2D" => "Camera2D",
                "Camera3D" => "Camera3D",
                "AudioStreamPlayer" => "AudioStreamPlayer",
                "AudioStreamPlayer2D" => "AudioStreamPlayer2D",
                "AudioStreamPlayer3D" => "AudioStreamPlayer3D",
                
                // Default to Node if unknown
                _ => "Node" 
            };
        }
        
        // Check if a type is a custom script
        private static bool IsCustomType(NodeInfo nodeInfo)
        {
            return !string.IsNullOrEmpty(nodeInfo.Script);
        }
    }

    // Represents a node in a Godot scene
    public class NodeInfo
    {
        public string Name { get; set; } = "";
        public string Path { get; set; } = "";
        public string Type { get; set; } = "Node";
        public string? Script { get; set; } = null;
        public bool IsExportedProperty { get; set; } = false;
        public Dictionary<string, string> Properties { get; set; } = new Dictionary<string, string>();
    }
}

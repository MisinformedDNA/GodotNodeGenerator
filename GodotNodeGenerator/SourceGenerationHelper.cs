using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Text;

namespace GodotNodeGenerator
{
    internal static class SourceGenerationHelper
    {
        // The source code for the attribute, which will be embedded in the assembly
        public static readonly string AttributeText = @"
using System;

namespace GodotNodeGenerator
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class NodeGeneratorAttribute : Attribute
    {
        public string? ScenePath { get; }

        public NodeGeneratorAttribute(string? scenePath = null)
        {
            ScenePath = scenePath;
        }
    }
}";

        // Generate node accessor code
        public static string GenerateNodeAccessors(
            string namespaceName, 
            string className, 
            List<NodeInfo> nodeInfos)
        {
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
using Godot;

namespace {namespaceName}
{{
    // Generated node accessors for {className}
    public partial class {className}
    {{");

            // Generate a property for each node
            foreach (var nodeInfo in nodeInfos)
            {
                var safeName = MakeSafeIdentifier(nodeInfo.Name);
                var godotType = MapGodotTypeToCS(nodeInfo.Type);
                
                sb.AppendLine($@"
        private {godotType}? _{safeName};
        
        /// <summary>
        /// Gets the {nodeInfo.Name} node (path: ""{nodeInfo.Path}"")
        /// </summary>
        public {godotType} {safeName} => 
            _{safeName} ??= GetNode<{godotType}>(""{nodeInfo.Path}"");");
            }

            sb.AppendLine(@"    }
}");

            return sb.ToString();
        }

        // Convert a node name to a valid C# identifier
        private static string MakeSafeIdentifier(string name)
        {
            // Simple implementation - replace invalid characters with underscore
            var result = new StringBuilder();
            
            // Ensure it starts with a letter or underscore
            if (!char.IsLetter(name[0]) && name[0] != '_')
            {
                result.Append('_');
            }
            
            foreach (var c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    result.Append(c);
                }
                else
                {
                    result.Append('_');
                }
            }
            
            return result.ToString();
        }

        // Map Godot node types to C# types
        private static string MapGodotTypeToCS(string godotType)
        {
            return godotType switch
            {
                "Node" => "Node",
                "Node2D" => "Node2D",
                "Node3D" => "Node3D",
                "Control" => "Control",
                "Sprite2D" => "Sprite2D",
                "Label" => "Label",
                "Button" => "Button",
                "Camera2D" => "Camera2D",
                "Camera3D" => "Camera3D",
                // Add more mappings as needed
                _ => "Node" // Default to Node if unknown
            };
        }
    }

    // Represents a node in a Godot scene
    public class NodeInfo
    {
        public string Name { get; set; } = "";
        public string Path { get; set; } = "";
        public string Type { get; set; } = "Node";
    }
}
